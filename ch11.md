# Transform Again, Naturally

我们将基于每天编程中的实际工具来讨论 natural transformations。恰巧它们是范畴论的支柱，当应用数学推理和重构我们的代码时是不可或缺的。As such, I believe it is my duty to inform you about the lamentable injustice you are about to witness undoubtedly due to my limited scope. 我们开始吧。

## Curse This Nest

我想解决嵌套问题。 Not the instinctive urge felt by soon to be mothers wherein they tidy and rearrange with obsessive compulsion, 但是......实际上，想到这一点，我们将在接下来的章节中看到这一点。 无论如何，我的意思是嵌套是将两种或更多种不同的类型挤在一起形成一个值，像新生儿一样蜷缩在一起。

```js
Right(Maybe('b'));

IO(Task(IO(1000)));

[Identity('bee thousand')];
```

到目前为止，我们已经设法通过精心设计的例子来回避这种常见的情况，但实际上，作为一种代码，类型在包装自己时像耳塞一样纠结自己。 如果我们不仔细地维持组织好的类型，我们的代码会比猫咪咖啡馆里的披头族的头发更凌乱。

## A Situational Comedy

```js
// getValue :: Selector -> Task Error (Maybe String)
// postComment :: String -> Task Error Comment
// validate :: String -> Either ValidationError String
// saveComment :: () -> Task Error (Maybe (Either ValidationError (Task Error Comment)))
const saveComment = compose(
    map(map(map(postComment))),
    map(map(validate)),
    getValue('#comment'),
);
```

这帮人都在这里，对我们的签名感到非常失望。 请允许我简要解释代码。 我们首先通过 getValue('#comment') 获取用户输入，这是一个在元素上检索文本的操作。
现在，它可能会错误地发现元素或值字符串可能不存在，因此它返回 Task Error (Maybe String)。 之后，我们必须映射 Task 和 Maybe 两者以传递我们的文本进行验证，这又使我们返回 ValidationError 或者 String。 然后映射数天以在我们当前的 Task Error (Maybe (ValidationError String )) 中发送字符串到  postComment 中，该函数返回我们生成的 Task。

多么可怕的一团糟。 乱拼接的抽象类型，平庸的类型表现主义，polymorphic Pollock，monolithic Mondrian。 这个常见问题有很多解决方案。 我们可以将这些类型组合成一个巨大的容器，并将它们分类、均质化、解构等等。 在本章中，我们将重点介绍通过 natural transformations 对它们进行均质化。